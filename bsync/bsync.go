// Package bsync implements point-to-point block-syncing between a local and remote source
// it's like rsync, but specific to block based content addressed systems
package bsync

import (
	"context"
	"fmt"
	"io"
	"math/rand"

	"github.com/qri-io/qri/base"
	"github.com/qri-io/qri/manifest"

	"gx/ipfs/QmPSQnBKM9g7BaUcZCvswUJVscQ1ipjmwxN5PXCjkp9EQ7/go-cid"
	ipld "gx/ipfs/QmR7TcHkR9nxkUorfi8XMTAMLUK7GiP64TWWBzY3aacc1o/go-ipld-format"
	coreiface "gx/ipfs/QmUJYo4etAQqFfSS2rarFAE97eNGB8ej64YkRT2SmsYD4r/go-ipfs/core/coreapi/interface"
)

// Progress tracks completion of a sync task. each element in the slice represents
// a block, the element itself must be a number from 0-100 representing the
// transmission completion of that block. 0 = nothing sent, 100 = finished.
type Progress []uint16

// Percentage expressess the completion
func (p Progress) Percentage() (pct float32) {
	for _, bl := range p {
		pct += float32(bl) / float32(100)
	}
	return (pct / float32(len(p))) * 100
}

// CompletedBlocks returns the number of blocks that are completed
func (p Progress) CompletedBlocks() (count int) {
	for _, bl := range p {
		if bl == 100 {
			count++
		}
	}
	return count
}

// Complete returns weather progress is finished
func (p Progress) Complete() bool {
	for _, bl := range p {
		if bl != 100 {
			return false
		}
	}
	return true
}

// Response defines the result of sending a block, or attempting to send a block
type Response struct {
	Hash   string
	Status ResponseStatus
	Err    error
}

// ResponseStatus defines types of results for a request
type ResponseStatus int

const (
	// StatusErrored indicates the request failed and cannot be retried
	StatusErrored ResponseStatus = -1
	// StatusOk indicates the request comp
	StatusOk ResponseStatus = 0
	// StatusRetry indicates the request can be attempted again
	StatusRetry ResponseStatus = 1
)

// Remote is an interface for a source that can be synced to
type Remote interface {
	// Remotes must be "pushable"
	ReqSend(mfst *manifest.Manifest) (sid string, diff *manifest.Manifest, err error)
	// SendBlock
	SendBlock(sid, hash string, data []byte) Response
}

// Send coordinates sending a manifest to a receiver, tracking progress and state
type Send struct {
	sid         string             // session ID for this push, generated by receiver
	ctx         context.Context    // session context
	mfst        *manifest.Manifest // manifest we're sending
	diff        *manifest.Manifest // returned difference
	lng         ipld.NodeGetter    // local NodeGetter (Block Getter)
	remote      Remote             // place we're sending to
	parallelism int                // number of "tracks" for sending along
	prog        Progress           // progress state
	progCh      chan Progress
	blocksCh    chan string
	responses   chan Response
}

// sender is a parallizable, stateless struct that sends blocks
type sender struct {
	sid       string
	ctx       context.Context
	blocksCh  chan string
	responses chan Response
	stopCh    chan bool
	lng       ipld.NodeGetter
	remote    Remote
}

func (s sender) start() {
	go func() {
		for {
			select {
			case hash := <-s.blocksCh:
				id, err := cid.Parse(hash)
				if err != nil {
					s.responses <- Response{
						Hash:   hash,
						Status: StatusErrored,
						Err:    err,
					}
				}
				node, err := s.lng.Get(s.ctx, id)
				if err != nil {
					s.responses <- Response{
						Hash:   hash,
						Status: StatusErrored,
						Err:    err,
					}
					continue
				}
				s.responses <- s.remote.SendBlock(s.sid, hash, node.RawData())
			case <-s.stopCh:
				return
			case <-s.ctx.Done():
				return
			}
		}

	}()
}

func (s sender) stop() {
	s.stopCh <- true
}

// NewSend gets a local path to a remote place using a local NodeGetter and a remote
func NewSend(ctx context.Context, lng ipld.NodeGetter, mfst *manifest.Manifest, remote Remote) (*Send, error) {
	ps := &Send{
		mfst:        mfst,
		lng:         lng,
		remote:      remote,
		parallelism: 4,
		blocksCh:    make(chan string, 8),
		progCh:      make(chan Progress, 8),
		responses:   make(chan Response),
	}
	return ps, nil
}

// Do executes the send
func (snd *Send) Do() (err error) {
	snd.sid, snd.diff, err = snd.remote.ReqSend(snd.mfst)
	if err != nil {
		return err
	}

	// fill in progress
	snd.prog = make(Progress, len(snd.mfst.Nodes))
	for i := range snd.prog {
		snd.prog[i] = 100
	}

	// then set missing blocks to
	for i, hash := range snd.mfst.Nodes {
		for _, missing := range snd.diff.Nodes {
			if hash == missing {
				snd.prog[i] = 0
			}
		}
	}

	go snd.updateProgress()

	// create senders
	sends := make([]sender, snd.parallelism)
	for i := 0; i <= snd.parallelism; i++ {
		sends[i] = sender{
			sid:       snd.sid,
			ctx:       snd.ctx,
			blocksCh:  snd.blocksCh,
			responses: snd.responses,
			lng:       snd.lng,
			remote:    snd.remote,
		}
		sends[i].start()
	}

	errCh := make(chan error)

	// receive block responses
	go func(sends []sender, errCh chan error) {
		for {
			select {
			case r := <-snd.responses:
				switch r.Status {
				case StatusOk:
					// this is the only place we should modify progress after creation
					for i, hash := range snd.mfst.Nodes {
						if r.Hash == hash {
							snd.prog[i] = 100
						}
					}
					go snd.updateProgress()
					if snd.prog.Complete() {
						errCh <- nil
						return
					}
				case StatusErrored:
					for _, s := range sends {
						s.stop()
					}
					errCh <- r.Err
				case StatusRetry:
					snd.blocksCh <- r.Hash
				}
			}
		}
	}(sends, errCh)

	// fill queue with missing blocks to kick off the send
	go func() {
		for _, hash := range snd.diff.Nodes {
			snd.blocksCh <- hash
		}
	}()

	// block until send on errCh
	return <-errCh
}

func (snd *Send) updateProgress() {
	snd.progCh <- snd.prog
}

// Receive tracks state of receiving a manifest of blocks from a remote
type Receive struct {
	sid       string
	ctx       context.Context
	lng       ipld.NodeGetter
	dag       coreiface.DagAPI
	batch     coreiface.DagBatch
	mfst      *manifest.Manifest
	diff      *manifest.Manifest
	prog      Progress
	responses chan Response
	pch       chan Progress
}

// NewReceive creates a receive state machine
func NewReceive(ctx context.Context, lng ipld.NodeGetter, dag coreiface.DagAPI, mfst *manifest.Manifest) (*Receive, error) {
	diff, err := base.Missing(ctx, lng, mfst)
	if err != nil {
		return nil, err
	}

	r := &Receive{
		sid:   randStringBytesMask(10),
		ctx:   ctx,
		lng:   lng,
		dag:   dag,
		batch: dag.Batch(ctx),
		mfst:  mfst,
		diff:  diff,
	}

	return r, nil
}

// ReceiveBlock accepts a block from the sender, placing it in the local blockstore
func (r *Receive) ReceiveBlock(hash string, data io.Reader) Response {
	// TODO - check hash
	// r.batch.Put(r.ctx, )

	return Response{
		Hash:   hash,
		Status: StatusErrored,
		Err:    fmt.Errorf("not finished"),
	}
}

// the best stack overflow answer evaarrr: https://stackoverflow.com/a/22892986/9416066
const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
const (
	letterIdxBits = 6                    // 6 bits to represent a letter index
	letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
	letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
)

func randStringBytesMask(n int) string {
	b := make([]byte, n)
	// A rand.Int63() generates 63 random bits, enough for letterIdxMax letters!
	for i, cache, remain := n-1, rand.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = rand.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(letterBytes) {
			b[i] = letterBytes[idx]
			i--
		}
		cache >>= letterIdxBits
		remain--
	}

	return string(b)
}
