// IDL file for log service
namespace logfb;

// setting file_identifier adds a "magic number" to bytes 4-7 to use as a
// sanity check for a "Qri FlatBuffer File". As our use of flatbuffers grows
// this file identifier should remain as the top level identifier for all
// qri flatbuffer schemas
file_identifier "QFBF";

// for our use this is mainly an annotation. this file extension for a 
// "qri flatbuffer" file should be .qfb
file_extension "qfb";

// flatbuffers in go presently don't support a vector of unions, so we can't
// break operations out into individual structs & union them, which would be
// the smart choice here. To get around this, the fields of operation itself
// are a union of all fields defined by operations. Thankfully there's a fair
// amount of overlap, even more if we abuse field names a bit.
// Not all operations will use all fields.
//
// I've opted to use "Operation" and reserve "Op"
// as a keyword for the day where we can do a vector of a union type
table Operation {
  type:ushort;        // type of operation, two bytes
  timestamp:long;      // operation timestamp, for annotation purposes only
  ref:string;         // identifier of data this operation is documenting

  name:string;        // human-readable name for the reference
  prev:string;        // previous reference in a causal history

  size:int;           // size of the referenced value in bytes
  revisions:int;      // for counting sequential revisions from ref
	destination:string; // push operation destination
  note:string;        // operation annotation for users. eg: commit title
}

// Log is a list of operations
table Log {
  name:string;        // human component of a log label, cached from opset
  identifier:string;  // canonical component of a log label, cached from opset
  signature:string;   // cryptographic signature of opset hash
  opset:[Operation];  // append-only list of operations being logged
}

// Logset is a list of related logs. eg: A dataset name correlates to a logset, 
// with one log per author branch of history. 
// eg2: A set of authors also correlates to a collection of logs, with one log 
// for each user key
table Logset {
  name:string;        // human component of a log label, cached from opset
  identifier:string;  // canonical component of a log lable, cached from opset
  signer:string;      // identifier for who signed this logset
  signature:string;   // cryptographic signature attesting to set integrity
  root:string;        // root caches the log that originated this set
  logs:[Log];         // collection of logs 
}

// Book is an author's journal of logs
table Book {
  name:string;        // book author name
  identifier:string;  // book author identifier
  authors:[Logset];   // list of author keys
  datasets:[Logset];  // named dataset logs
}

root_type Book;